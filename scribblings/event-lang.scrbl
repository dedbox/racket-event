#lang scribble/manual

@title{Event-lang: synchronizable event programming}
@author{@author+email["Eric Griffis" "dedbox@gmail.com"]}

@(require
  racket/sandbox
  scribble/examples
  (for-label event
             racket/base
             racket/contract/base))

@(random-seed 5)

@(define (rtech . args)
   (apply tech #:doc '(lib "scribblings/reference/reference.scrbl") args))

@(define event-evaluator
   (parameterize
       ([sandbox-output 'string]
        [sandbox-error-output 'string]
        [sandbox-memory-limit 50]
        [sandbox-eval-limits '(30 50)]
        [sandbox-make-inspector current-inspector])
     (make-evaluator 'racket #:requires '(event))))

@(define-syntax-rule (example expr ...)
   @examples[
     #:eval event-evaluator
     #:label #f
     expr ...
   ])

Event-lang is a DSL for creating @rtech{synchronizable events}. It provides a
primitive lifting form (@racket[pure]) and a set of combinators for making
composite events that synchronize sub-events in a pre-determined sequence or
simultaneously.

@; The @racket[event] form translates an ordinary Racket expression into a
@; @rtech{synchronizable event} that, when synchronized on, evaluates its
@; expression and then becomes @rtech{ready for synchronization} with the
@; evaluation result as its @rtech{synchronization result}. Sub-expressions are
@; lifted strategically to make large or long-lived events easier to create and
@; re-use.

@; @example[
@;   (define ch (make-channel))
@;   (sync
@;    (loop (λ _ (handle-evt ch write)))
@;    (reduce
@;     (λ (i) (seq (channel-put-evt ch i) (pure (sub1 i))))
@;     (λ (i j) (= j 0))
@;     9))
@; ]

@; @section{Event Construction}

@; @defmodule[event/event]

@; @defform[(event expr ...+)]{

@;   Returns a @rtech{synchronizable event} that delays evaluation of expression
@;   sequence @racket[#,(var expr) #,(var ...)] until synchronized on and then
@;   uses the evaluation result as its @rtech{synchronization result}.

@;   @example[
@;     (event 5 6 7)
@;     (event-do 5 6 7)
@;     (event-print 5 6 7)
@;   ]
@; }

@; @defform[(esc expr)]{

@;   This form can only appear as an expression within an @racket[event] form.
@;   Use it to embed a value directly into the result.

@;   @example[
@;     (event (esc 5))
@;   ]
@; }

@; @defform[(event-do expr ...+)]{

@;   Calls @racket[(event #,(var expr) #,(var ...))] and immediately synchronizes
@;   the generated event.

@;   @; @example[
@;   @;   (event-do (let ([x 3] [y 2]) (+ x y)))
@;   @; ]
@; }

@; @defform[(event-print expr ...+)]{

@;   Prints the event generated by @racket[(event #,(var expr) #,(var ...))] in
@;   combinator form.

@;   @; @example[
@;   @;   (event-print (let ([x 3] [y 2]) (+ x y)))
@;   @; ]
@; }

@; @defform[(event-debug expr...+)]{

@;   Prints the event generated by @racket[(event #,(var expr) #,(var ...))],
@;   including all intermediate representations. Synchronizes the generated event
@;   and prints the @rtech{synchronization result}.

@;   @; @example[
@;   @;   (event-debug (let ([x 3] [y 2]) (+ x y)))
@;   @; ]
@; }

@defmodule[event]

@section{Sequential Combinators}

@defform[(pure datum)]{

  Lifts @var[datum] into a into a @rtech{synchronizable event}. Delays
  evaluation of @var[datum] until a thread synchronizes on it. The
  @rtech{synchronization result} is the evaluation result.

  @example[
    (define N 0)
    (define evt (pure (set! N (add1 N))))
    (sync evt)
    (sync evt)
    N
  ]
}

@defproc[(return [v any/c]) evt? #:value (pure v)]{

  Evaluates @var[v] and then lifts the result into an event. Returns a
  @rtech{synchronizable event} that does nothing and uses @var[v] as its
  @rtech{synchronization result}.

  @example[
    (define N 0)
    (define evt (return (set! N (add1 N))))
    (sync evt)
    (sync evt)
    N
  ]
}

@deftogether[(
  @defproc[(args [E evt?] ...) evt?]
  @defproc[(args* [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that evaluates @var[Es] in order and
  then applies @racket[values] to the @rtech{synchronization results}.

  @example[
    (sync (args (pure 1) (pure 2) (pure 3)))
    @; (event-do (args 1 2 3))
  ]
}

@deftogether[(
  @defproc[(fmap [f (-> any/c ... any)] [E evt?] ...) evt?]
  @defproc[(fmap* [f (-> any/c ... any)] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[Es] in order
  and then applies @var[f] to the @rtech{synchronization results}.

  @example[
    (sync (fmap + (pure 1) (pure 2) (pure 3)))
    @; (event-do (fmap + 1 2 3))
  ]
}

@deftogether[(
  @defproc[(app [F evt?] [E evt?] ...) evt?]
  @defproc[(app* [F evt?] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[F] and
  @var[Es] in order and then applies the @rtech{synchronization result} of the
  former to the @rtech{synchronization results} of the latter.

  @example[
    (sync (app (pure +) (pure 1) (pure 2) (pure 3)))
    @; (event-do (app + 1 2 3))
  ]
}

@deftogether[(
  @defproc[(bind [E evt?] ... [f (-> any/c ... evt?)]) evt?]
  @defproc[(bind* [Es (listof evt?)] [f (-> any/c ... evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[Es] in order
  and then becomes the event returned from @var[f] applied to the
  @rtech{synchronization results}.

  @example[
    (sync
     (bind
      (pure 1)
      (pure 2)
      (pure 3)
      (compose return +)))
    @; (event-do (bind 1 2 3 (compose return +)))
  ]
}

@defproc[(seq [E evt?] ...+) evt?]{

  Returns a @rtech{synchronizable event} that synchronizes @var[E]s in order
  and then uses the final @rtech{synchronization result} as its own.

  @example[
    (sync (seq (pure 1) (pure 2) (pure 3)))
    @; (event-do (seq 1 2 3))
  ]
}

@defproc[(seq0 [E evt?] ...+) evt?]{

  Returns a @rtech{synchronizable event} that synchronizes @var[E]s in order
  and then uses the first @rtech{synchronization result} as its own.

  @example[
    (sync (seq0 (pure 1) (pure 2) (pure 3)))
    @; (event-do (seq0 1 2 3))
  ]
}

@defproc[(test [E1 evt?] [E2 evt?] [E3 evt?]) evt?]{

  Returns a @rtech{synchronizable event} that becomes either @var[E2] or
  @var[E3]. If the @rtech{synchronization result} of @var[E1] is not
  @racket[#f], it becomes @var[E2]. Otherwise, it becomes @var[E3].

  @example[
    (sync (test (pure #t) (pure 1) (pure 2)))
    (sync (test (pure #f) (pure 1) (pure 2)))
    @; (event-do (test #t 1 2))
    @; (event-do (test #f 1 2))
  ]
}

@deftogether[(
  @defproc[(series [E evt?] [f (-> any/c evt)] ...) evt?]
  @defproc[(series* [E evt?] [fs (listof (-> any/c evt?))]) evt?]
)]{

  Returns a @rtech{synchronizable event} that applies @var[f]s in series,
  starting with the @rtech{synchronization result} of @var[E] and continuing
  with the @rtech{synchronization result} of the event generated by the
  previous @var[f]. Uses the final @rtech{synchronization result} as its own.

  @example[
    (sync
     (series
      (pure 1)
      (compose return (curry + 2))
      (compose return (curry * 3))))
  ]
}

@deftogether[(
  @defproc[
    (reduce [f (-> any/c ... evt?)]
            [check (-> any/c ... boolean?)]
            [v any/c] ...)
    evt?]
  @defproc[
    (reduce* [f (-> any/c ... evt?)]
             [check (-> any/c ... boolean?)]
             [vs (listof any/c)])
    evt?]
)]{

  Returns a @rtech{synchronizable event} that applies @var[f] to a set of
  values recursively, starting with @racket[#,(var v) #,(var ...)] or @var[vs]
  and continuing with the @rtech{synchronization result} of the event
  generated by applying @var[f] to the previous results. Applies @var[check]
  to an argument list created by appending @racket[#,(var v) #,(var ...)] or
  @var[vs] onto the results of @var[f]. Becomes @rtech{ready for
  synchronization} when @var[check] returns @racket[#t]. Uses the final
  @rtech{synchronization result} as its own.

  @example[
    (sync
     (reduce
      (λ (x) (pure (add1 x)))
      (λ (x y) (>= y 10))
      0))
  ]
}

@deftogether[(
  @defproc[(loop [f (-> any/c ... evt?)] [v any/c] ...) evt?]
  @defproc[(loop* [f (-> any/c ... evt?)] [vs (listof any/c)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that applies @var[f] to a value
  recursively, starting with @racket[#,(var v) #,(var ...)] or @var[vs] and
  continuing with the @rtech{synchronization result} of the event generated by
  applying @var[f] to the previous results. Never becomes @rtech{ready for
  synchronization}.

  @example[
    (with-handlers ([number? values])
      (sync (loop (λ (x)
                    (if (< x 10)
                        (pure (add1 x))
                        (raise x)))
                  0)))
  ]
}

@section{Concurrent Combinators}

@deftogether[(
  @defproc[(async-set [E evt?] ...) evt?]
  @defproc[(async-set* [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @racket[#,(var E)
  #,(var ...)] or @var[Es] concurrently and then applies @racket[values] to a
  list of the @rtech{synchronization results} in order of completion.

  @example[
    (define evt
      (handle-evt (async-set (pure 1) (pure 2) (pure 3)) list))
    (sync evt)
    (sync evt)
    (sync evt)
  ]
}

@deftogether[(
  @defproc[(async-args [E evt?] ...) evt?]
  @defproc[(async-args* [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that evaluates @racket[#,(var E)
  #,(var ...)] or @var[Es] concurrently and then applies @racket[values] to a
  list of the @rtech{synchronization results} in the order defined.

  @example[
    (define evt
      (handle-evt
       (async-args (pure 1) (pure 2) (pure 3))
       list))
    (sync evt)
  ]
}

@deftogether[(
  @defproc[(async-fmap [f (-> any/c ... any)] [E evt?] ...) evt?]
  @defproc[(async-fmap* [f (-> any/c ... any)] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @racket[#,(var E)
  #,(var ...)] or @var[Vs] concurrently and then applies @var[f] to a list of
  the @rtech{synchronization results}.

  @example[
    (sync (async-fmap + (pure 1) (pure 2) (pure 3)))
  ]
}

@deftogether[(
  @defproc[(async-app [F evt?] [E evt?] ...) evt?]
  @defproc[(async-app* [F evt?] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[F] and
  @racket[#,(var E) #,(var ...)] or @var[Es] concurrently and then applies the
  @rtech{synchronization result} of the former to a list of the
  @rtech{synchronization results} of the latter.

  @example[
    (sync (async-app (pure +) (pure 1) (pure 2) (pure 3)))
  ]
}

@deftogether[(
  @defproc[(async-bind [E evt?] ... [f (-> any/c ... evt?)]) evt?]
  @defproc[(async-bind* [Es (listof evt?)] [f (-> any/c ... evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @racket[#,(var E)
  #,(var ...)] or @var[Es] concurrently and then becomes the event returned
  from @var[f] applied to a list of the @rtech{synchronization results}.

  @example[
    (sync
     (async-bind
      (seq (pure (print 1)) (pure 1))
      (seq (pure (print 2)) (pure 2))
      (seq (pure (print 3)) (pure 3))
      (compose return list)))
  ]
}

@section{Synchronization Gates}

@defmodule[event/gate]

A @deftech{gate} is a simple primitive for synchronizing many threads at once.
A gate is either opened or closed and is closed initially. Threads
synchronizing on a closed gate will block until the gate is opened. Once a
gate is opened, it cannot be closed.

@defproc[(gate? [v any/c]) boolean?]{

  Returns @racket[#t] if @var[v] is a @tech{gate}, @racket[#f] otherwise.

}

@defproc[(gate) gate?]{

  Creates and returns a new closed gate.

}

@defproc[(open-gate [g gate?]) void?]{

  Unblocks all threads blocked on the gate simultaneously.

}

@section{Racket Base}

@defmodule[event/base]

@subsection{Sequential}

@defform[(event-let ([id val-evt] ...) body-evt ...+)]{

  Creates a @rtech{synchronizable event} that Synchronizes the @var[val-evt]s
  from left to right and binds the @var[id]s to the results, then synchronizes
  the @var[body-evt]s. Uses the @rtech{synchronization result} of its final
  @var[body-evt] as its own.

  @example[
    (sync
     (event-let ([x (pure 1)]
                 [y (pure 2)])
       (pure (+ x y))))
  ]
}

@defform[(event-let* ([id val-evt] ...) body-evt ...+)]{

  Like @racket[event-let], but synchronizes the @var[val-evt]s one by one,
  binding each @var[id] as soon as the value is available. The @var[id]s are
  bound in the remaining @var[val-evt]s as well as the @var[body]s, and the
  @var[id]s need not be distinct; later bindings shadow earlier bindings.

  Creates a @rtech{synchronizable event} that Synchronizes the @var[val-evt]s
  from left to right and binds the @var[id]s to the results, then synchronizes
  the @var[body-evt]s. Uses the @rtech{synchronization result} of its final
  @var[body-evt] as its own.

  @example[
    (sync
     (event-let* ([x (pure 1)]
                  [y (pure (+ x 2))])
       (pure (+ x y))))
  ]
}

@defform[
  (event-cond event-cond-clause ...)
  #:grammar
  [(event-cond-clause [test-evt then-body-evt ...+]
                      [else then-body-evt ...+]
                      [test-evt => proc-evt]
                      [test-evt])]
]{

  ...
}

@deftogether[(
  @defproc[(event-list [E evt?] ...) evt?]
  @defproc[(event-list* [E evt?] ... [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes all @var[E]s in
  order and then uses a list of the results as its @rtech{synchronization
  result}.

  @example[
    (sync (event-list (pure 1) (pure 2) (pure 3)))
  ]
}

@defproc[(event-map [f procedure?] [Es (listof evt?)] ...+) evt?]{

  Returns a @rtech{synchronizable event} that synchronizes the elements of the
  @var[Es] lists and applies @var[f] to the @rtech{synchronization results} of
  the elements, from the first elements to the last. The @var[f] argument must
  accept the same number of arguments as the number of supplied @var[Es]s, and
  all @var[Es]s must have the same number of elements. The
  @rtech{synchronization result} is a list containing each result of @var[f]
  in order.

  @example[
    (sync
     (async-map
      +
      (list (pure 1) (pure 2) (pure 3))
      (list (pure 4) (pure 5) (pure 6))))
  ]
}

@subsection{Concurrent}

@defform[(async-let ([x Ex] ...) E ...+)]{

  Produces a @rtech{synchronizable event} that synchronizes @racket[#,(var Ex)
  #,(var ...)] concurrently, binds the @rtech{synchronization results} to
  @racket[#,(var x) #,(var ...)] internally, then becomes @racket[(seq #,(var
  E) #,(var ...))].

  @example[
    (sync
     (async-let
         ([x (seq (pure (print 1)) (pure 1))]
          [y (seq (pure (print 2)) (pure 2))]
          [z (seq (pure (print 3)) (pure 3))])
       (pure (values x y z))))
  ]
}

@deftogether[(
  @defproc[(async-list [E evt?] ...) evt?]
  @defproc[(async-list* [E evt?] ... [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes all @var[E]s
  simultaneously and becomes @rtech{ready for synchronization} when all the
  @var[E]s are ready. The @rtech{synchronization result} is a list of the
  results, in order.

  @example[
    (sync (event-list (pure 1) (pure 2) (pure 3)))
  ]
}

@deftogether[(
  @defproc[(async-void [E evt?] ...) evt?]
  @defproc[(async-void* [E evt?] ... [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes all @var[E]s
  simultaneously and becomes @rtech{ready for synchronization} when all the
  @var[E]s are ready. The @rtech{synchronization result} is a single void.

  @example[
    (sync (async-void (pure 1) (pure 2) (pure 3)))
  ]
}

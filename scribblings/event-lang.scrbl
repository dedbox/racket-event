#lang scribble/manual

@title{Event-lang: Synchronizable Event Programming}
@author{@author+email["Eric Griffis" "dedbox@gmail.com"]}

@(require
  racket/sandbox
  scribble/examples
  (for-label event
             racket/base
             racket/contract/base))

@(random-seed 5)

@(define (rtech . args)
   (apply tech #:doc '(lib "scribblings/reference/reference.scrbl") args))

@(define event-evaluator
   (parameterize
       ([sandbox-output 'string]
        [sandbox-error-output 'string]
        [sandbox-memory-limit 50]
        [sandbox-eval-limits '(30 50)]
        [sandbox-make-inspector current-inspector])
     (make-evaluator 'racket #:requires '(event))))

@(define-syntax-rule (example expr ...)
   @examples[
     #:eval event-evaluator
     #:label #f
     expr ...
   ])

Event-lang is a DSL for creating @rtech{synchronizable events}.

The @racketmodname[event/sequential] module provides the @racket[pure]
primitive lifting form and a set of sequential combinators. The
@racketmodname[event] module re-exports these bindings and includes a
sophisticated @racket[event] constructor. The @racketmodname[event/concurrent]
module provides concurrent variants of the sequential combinators.

The @racket[event] form takes an ordinary Racket expression, auto-lifts
sub-expressions into sub-events, and produces an event that, when synchronized
on, evaluates the expression and becomes @rtech{ready for synchronization}
with the evaluation result as its @rtech{synchronization result}.

@section{Event Construction}

@defmodule[event]

@defform[(event expr ...+)]{

  Returns as @rtech{synchronizable event} that delays evaluation of
  @racket[#,(var expr) #,(var ...)] until a thread synchronizes on it. The
  @rtech{synchronization result} is the evaluation result.

  @example[
    (event 5)
    (sync (event 5))
  ]
}

@defform[(esc expr)]{

  This form can only appear as an expression within an @racket[event] form.
  Use it to embed a value directly into the result.

  @example[
    (event (esc 5))
  ]
}

@defform[(event-do expr ...+)]{

  Calls @racket[(event #,(var expr) #,(var ...))] and immediately synchronizes
  the generated event.

  @; @example[
  @;   (event-do (let ([x 3] [y 2]) (+ x y)))
  @; ]
}

@defform[(event-print expr ...+)]{

  Prints the event generated by @racket[(event #,(var expr) #,(var ...))] in
  combinator form.

  @; @example[
  @;   (event-print (let ([x 3] [y 2]) (+ x y)))
  @; ]
}

@defform[(event-debug expr...+)]{

  Prints the event generated by @racket[(event #,(var expr) #,(var ...))],
  including all intermediate representations. Synchronizes the generated event
  and prints the @rtech{synchronization result}.

  @; @example[
  @;   (event-debug (let ([x 3] [y 2]) (+ x y)))
  @; ]
}

@section{Sequential Combinators}

@defmodule[event/sequential]

@defform[(pure datum)]{

  Lifts @var[datum] into a into a @rtech{synchronizable event}. Delays
  evaluation of @var[datum] until a thread synchronizes on it. The
  @rtech{synchronization result} is the evaluation result.

  @example[
    (define N 0)
    (define evt (pure (set! N (add1 N))))
    (sync evt)
    (sync evt)
    N
  ]
}

@defproc[(return [v any/c]) evt? #:value (pure v)]{

  Evaluates @var[v] and then lifts the result into an event. Returns a
  @rtech{synchronizable event} that does nothing and uses @var[v] as its
  @rtech{synchronization result}.

  @example[
    (define N 0)
    (define evt (return (set! N (add1 N))))
    (sync evt)
    (sync evt)
    N
  ]
}

@deftogether[(
  @defproc[(args [E evt?] ...) evt?]
  @defproc[(args* [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that evaluates @var[Es] in order and
  then applies @racket[values] to the @rtech{synchronization results}.

  @example[
    (sync (args (pure 1) (pure 2) (pure 3)))
    (event-do (args 1 2 3))
  ]
}

@deftogether[(
  @defproc[(fmap [f (-> any/c ... any)] [E evt?] ...) evt?]
  @defproc[(fmap* [f (-> any/c ... any)] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[Es] in order
  and then applies @var[f] to the @rtech{synchronization results}.

  @example[
    (sync (fmap + (pure 1) (pure 2) (pure 3)))
    (event-do (fmap + 1 2 3))
  ]
}

@deftogether[(
  @defproc[(app [F evt?] [E evt?] ...) evt?]
  @defproc[(app* [F evt?] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[F] and
  @var[Es] in order and then applies the @rtech{synchronization result} of the
  former to the @rtech{synchronization results} of the latter.

  @example[
    (sync (app (pure +) (pure 1) (pure 2) (pure 3)))
    (event-do (app + 1 2 3))
  ]
}

@deftogether[(
  @defproc[(bind [f (-> any/c ... evt?)] [E evt?] ...) evt?]
  @defproc[(bind* [f (-> any/c ... evt?)] [Es (listof evt?)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that synchronizes @var[Es] in order
  and then becomes the event returned from @var[f] applied to the
  @rtech{synchronization results}.

  @example[
    (sync
     (bind
      (compose return +)
      (pure 1)
      (pure 2)
      (pure 3)))
    (event-do (bind (compose return +) 1 2 3))
  ]
}

@defproc[(seq [E evt?] ...+) evt?]{

  Returns a @rtech{synchronizable event} that synchronizes @var[E]s in order
  and then uses the final @rtech{synchronization result} as its own.

  @example[
    (sync (seq (pure 1) (pure 2) (pure 3)))
    (event-do (seq 1 2 3))
  ]
}

@defproc[(seq0 [E evt?] ...+) evt?]{

  Returns a @rtech{synchronizable event} that synchronizes @var[E]s in order
  and then uses the first @rtech{synchronization result} as its own.

  @example[
    (sync (seq0 (pure 1) (pure 2) (pure 3)))
    (event-do (seq0 1 2 3))
  ]
}

@defproc[(test [E1 evt?] [E2 evt?] [E3 evt?]) evt?]{

  Returns a @rtech{synchronizable event} that becomes either @var[E2] or
  @var[E3]. If the @rtech{synchronization result} of @var[E1] is not
  @racket[#f], it becomes @var[E2]. Otherwise, it becomes @var[E3].

  @example[
    (sync (test (pure #t) (pure 1) (pure 2)))
    (sync (test (pure #f) (pure 1) (pure 2)))
    (event-do (test #t 1 2))
    (event-do (test #f 1 2))
  ]
}

@deftogether[(
  @defproc[(series [E evt?] [f (-> any/c evt)] ...) evt?]
  @defproc[(series* [E evt?] [fs (listof (-> any/c evt?))]) evt?]
)]{

  Returns a @rtech{synchronizable event} that applies @var[f]s in series,
  starting with the @rtech{synchronization result} of @var[E] and continuing
  with the @rtech{synchronization result} of the event generated by the
  previous @var[f]. Uses the final @rtech{synchronization result} as its own.

  @example[
    (sync
     (series
      (pure 1)
      (compose return (curry + 2))
      (compose return (curry * 3))))
  ]
}

@deftogether[(
  @defproc[
    (reduce [f (-> any/c ... evt?)]
            [check (-> any/c ... boolean?)]
            [v any/c] ...)
    evt?]
  @defproc[
    (reduce* [f (-> any/c ... evt?)]
             [check (-> any/c ... boolean?)]
             [vs (listof any/c)])
    evt?]
)]{

  Returns a @rtech{synchronizable event} that applies @var[f] to a set of
  values recursively, starting with @racket[#,(var v) #,(var ...)] or @var[vs]
  and continuing with the @rtech{synchronization result} of the event
  generated by applying @var[f] to the previous results. Applies @var[check]
  to an argument list created by appending @racket[#,(var v) #,(var ...)] or
  @var[vs] onto the results of @var[f]. Becomes @rtech{ready for
  synchronization} when @var[check] returns @racket[#t]. Uses the final
  @rtech{synchronization result} as its own.

  @example[
    (sync
     (reduce
      (λ (x) (pure (add1 x)))
      (λ (x y) (>= y 10))
      0))
  ]
}

@deftogether[(
  @defproc[(loop [f (-> any/c ... evt?)] [v any/c] ...) evt?]
  @defproc[(loop* [f (-> any/c ... evt?)] [vs (listof any/c)]) evt?]
)]{

  Returns a @rtech{synchronizable event} that applies @var[f] to a value
  recursively, starting with @racket[#,(var v) #,(var ...)] or @var[vs] and
  continuing with the @rtech{synchronization result} of the event generated by
  applying @var[f] to the previous results. Never becomes @rtech{ready for
  synchronization}.

  @example[
    (with-handlers ([number? values])
      (sync (loop (λ (x)
                    (if (< x 10)
                        (pure (add1 x))
                        (raise x)))
                  0)))
  ]
}

@; @section{Concurrent Combinators}

@; @defmodule[event/async-monad]

@; @defform[(async-let ([x Ex] ...) E ...+)]{

@;   Produces a @rtech{synchronizable event} that synchronizes @racket[#,(var Ex)
@;   #,(var ...)] concurrently, binds the @rtech{synchronization results} to
@;   @racket[#,(var x) #,(var ...)] internally, then becomes @racket[(seq #,(var
@;   E) #,(var ...))].

@;   @example[
@;     (sync
@;      (async-let
@;          ([x (seq (pure (print 1)) (pure 1))]
@;           [y (seq (pure (print 2)) (pure 2))]
@;           [z (seq (pure (print 3)) (pure 3))])
@;        (pure (values x y z))))
@;   ]
@; }

@; @deftogether[(
@;   @defproc[(async-set [E evt?] ...) evt?]
@;   @defproc[(async-set* [Es (listof evt?)]) evt?]
@; )]{

@;   Returns a @rtech{synchronizable event} that synchronizes @racket[#,(var E)
@;   #,(var ...)] or @var[Es] concurrently and then applies @racket[values] to a
@;   list of the @rtech{synchronization results} in order of completion.

@;   @example[
@;     (define evt
@;       (handle-evt (async-set (pure 1) (pure 2) (pure 3)) list))
@;     (sync evt)
@;     (sync evt)
@;     (sync evt)
@;   ]
@; }

@; @deftogether[(
@;   @defproc[(async-args [E evt?] ...) evt?]
@;   @defproc[(async-args* [Es (listof evt?)]) evt?]
@; )]{

@;   Returns a @rtech{synchronizable event} that evaluates @racket[#,(var E)
@;   #,(var ...)] or @var[Es] concurrently and then applies @racket[values] to a
@;   list of the @rtech{synchronization results} in the order defined.

@;   @example[
@;     (define evt
@;       (handle-evt
@;        (async-args (pure 1) (pure 2) (pure 3))
@;        list))
@;     (sync evt)
@;   ]
@; }

@; @deftogether[(
@;   @defproc[(async-fmap [f (-> any/c ... any)] [E evt?] ...) evt?]
@;   @defproc[(async-fmap* [f (-> any/c ... any)] [Es (listof evt?)]) evt?]
@; )]{

@;   Returns a @rtech{synchronizable event} that synchronizes @racket[#,(var E)
@;   #,(var ...)] or @var[Vs] concurrently and then applies @var[f] to a list of
@;   the @rtech{synchronization results}.

@;   @example[
@;     (sync (async-fmap + (pure 1) (pure 2) (pure 3)))
@;   ]
@; }

@; @deftogether[(
@;   @defproc[(async-app [F evt?] [E evt?] ...) evt?]
@;   @defproc[(async-app* [F evt?] [Es (listof evt?)]) evt?]
@; )]{

@;   Returns a @rtech{synchronizable event} that synchronizes @var[F] and
@;   @racket[#,(var E) #,(var ...)] or @var[Es] concurrently and then applies the
@;   @rtech{synchronization result} of the former to a list of the
@;   @rtech{synchronization results} of the latter.

@;   @example[
@;     (sync (async-app (pure +) (pure 1) (pure 2) (pure 3)))
@;   ]
@; }

@; @deftogether[(
@;   @defproc[(async-bind [f (-> any/c ... evt?)] [E evt?] ...) evt?]
@;   @defproc[(async-bind* [f (-> any/c ... evt?)] [Es (listof evt?)]) evt?]
@; )]{

@;   Returns a @rtech{synchronizable event} that synchronizes @racket[#,(var E)
@;   #,(var ...)] or @var[Es] concurrently and then becomes the event returned
@;   from @var[f] applied to a list of the @rtech{synchronization results}.

@;   @example[
@;     (sync
@;      (async-bind
@;       (compose return list)
@;       (seq (pure (print 1)) (pure 1))
@;       (seq (pure (print 2)) (pure 2))
@;       (seq (pure (print 3)) (pure 3))))
@;   ]
@; }
